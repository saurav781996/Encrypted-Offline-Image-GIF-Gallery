<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Encrypted Offline Image & GIF Gallery (IndexedDB + AES-GCM)</title>
  <link rel="icon" href="data:," />
  <style>
    /* (styles unchanged from your original, slightly trimmed) */
    :root{--bg:#0f1226;--panel:#161a36;--soft:#222651;--accent:#7c8cff;--accent-2:#50e3c2;--text:#eaf0ff;--muted:#9aa4d7}
    *{box-sizing:border-box} html,body{height:100%} body{margin:0;background:linear-gradient(180deg,var(--bg),#0b0e1e 60%);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{position:sticky;top:0;z-index:5;background:rgba(15,18,38,.8);backdrop-filter:blur(8px);border-bottom:1px solid #1f2350}
    .wrap{max-width:1100px;margin:0 auto;padding:16px} h1{margin:0;font-size:20px;letter-spacing:.3px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button,.file-label{appearance:none;border:1px solid #2b2f66;background:linear-gradient(180deg,#1b2050,#151a44);color:var(--text);padding:10px 14px;border-radius:14px;cursor:pointer;transition:.2s;box-shadow:0 1px 0 #2a2f62 inset,0 8px 24px rgba(0,0,0,.2)}
    button:hover,.file-label:hover{transform:translateY(-1px);border-color:#3940a5} button:disabled{opacity:.5;cursor:not-allowed}
    .file-label{display:inline-flex;align-items:center;gap:8px} input[type=file]{display:none}
    .stats{margin-left:auto;color:var(--muted);display:flex;align-items:center;gap:14px;flex-wrap:wrap}
    main{max-width:1100px;margin:14px auto 60px;padding:0 16px}
    .dropzone{border:2px dashed #2c326e;border-radius:18px;padding:22px;text-align:center;color:var(--muted);background:rgba(124,140,255,.06)}
    .dropzone.dragover{border-color:var(--accent);background:rgba(124,140,255,.12);color:var(--text)}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:14px;margin-top:16px}
    .card{position:relative;background:linear-gradient(180deg,#161a36,#121638);border:1px solid #22265a;border-radius:16px;overflow:hidden}
    .thumb{width:100%;height:150px;object-fit:cover;background:#0a0d20;display:block}
    .meta{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;color:var(--muted);font-size:12px}
    .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:70%}
    .badge{border:1px solid #2b2f66;border-radius:999px;padding:2px 8px}
    .select{position:absolute;top:8px;left:8px;background:rgba(0,0,0,.5);backdrop-filter:blur(4px);padding:6px;border-radius:10px}
    .actions{display:flex;gap:8px;padding:8px;border-top:1px solid #22265a}
    .actions button{flex:1;padding:8px;border-radius:10px}
    .empty{color:var(--muted);text-align:center;padding:28px}
    footer{position:fixed;inset:auto 0 0 0;background:rgba(15,18,38,.9);backdrop-filter:blur(8px);border-top:1px solid #1f2350}
    .footer-wrap{max-width:1100px;margin:0 auto;padding:10px 16px;display:flex;gap:10px;align-items:center}
    dialog{border:none;border-radius:16px;padding:0;max-width:90vw;background:#0e1333;color:var(--text);box-shadow:0 30px 80px rgba(0,0,0,.5)}
    .modal-head{padding:12px 16px;border-bottom:1px solid #22265a;display:flex;justify-content:space-between;align-items:center}
    .modal-body{padding:12px} .modal-body img{max-width:90vw;max-height:70vh;display:block}
    .close-x{background:transparent;border:0;color:var(--muted);font-size:22px;cursor:pointer}
    .hidden{display:none}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Encrypted Offline Image & GIF Gallery <span style="color:var(--accent)">‚Äî stored encrypted in your browser</span></h1>
      <div class="toolbar">
        <label class="file-label" title="Choose images">
          <input id="fileInput" type="file" accept="image/*" multiple />
          üì§ Upload Images
        </label>
        <label class="file-label" title="Import a previously exported .json file">
          <input id="importInput" type="file" accept="application/json" />
          üì• Import (.json)
        </label>
        <button id="exportSel" disabled>üíæ Export Selected</button>
        <button id="exportAll" disabled>üíæ Export All</button>
        <button id="selectAll" disabled>‚òëÔ∏è Select All</button>
        <button id="clearSel" disabled>üóëÔ∏è Delete Selected</button>
        <button id="clearAll" disabled>üßπ Clear All</button>
        <div class="stats" id="stats">0 items ¬∑ 0 MB used</div>
      </div>
    </div>
  </header>

  <main>
    <div id="dropzone" class="dropzone">Drag & drop images/GIFs here, or use the Upload button above.</div>
    <div id="gallery" class="grid" aria-live="polite"></div>
    <div id="emptyState" class="empty hidden">No images yet. Upload or drop some to get started ‚ú®</div>
  </main>

  <footer>
    <div class="footer-wrap">
      <div class="grow">Everything is saved locally using IndexedDB and encrypted with AES-GCM. Nothing leaves your device without export.</div>
      <small>Tip: Exported JSON contains decrypted images; keep it safe.</small>
    </div>
  </footer>

  <dialog id="viewer">
    <div class="modal-head">
      <div id="viewerName">Preview</div>
      <button class="close-x" onclick="viewer.close()">√ó</button>
    </div>
    <div class="modal-body"><img id="viewerImg" alt="Preview" /></div>
  </dialog>

  <script>
  // ------------------ Config / DB names ---------------------
  const DB_NAME = 'offline-image-gallery-v1-encrypted';
  const STORE = 'images';
  const META = 'meta';
  const DB_VERSION = 1;

  // ------------------ Crypto settings -----------------------
  const PBKDF2_ITERATIONS = 200000;
  const SALT_KEY = 'salt'; // stored in meta store
  const ENC_ALGO = { name: 'AES-GCM', length: 256 };
  let cryptoKey = null;
  let salt = null;

  // ------------------ IndexedDB helpers ---------------------
  let db;
  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const d = req.result;
        if(!d.objectStoreNames.contains(STORE)){
          const os = d.createObjectStore(STORE,{keyPath:'id'});
          os.createIndex('by_name','name',{unique:false});
        }
        if(!d.objectStoreNames.contains(META)){
          d.createObjectStore(META, { keyPath: 'k' });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  function txObjectStore(mode='readonly'){
    const t = db.transaction([STORE], mode);
    return t.objectStore(STORE);
  }
  function txMetaStore(mode='readonly'){
    const t = db.transaction([META], mode);
    return t.objectStore(META);
  }

  function putImageRecord(record){
    return new Promise((res,rej)=>{ const r = txObjectStore('readwrite').put(record); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) });
  }
  function deleteImageRecord(id){
    return new Promise((res,rej)=>{ const r = txObjectStore('readwrite').delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) });
  }
  function getAllRecords(){
    return new Promise((res,rej)=>{ const r = txObjectStore('readonly').getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error) });
  }
  function getManyRecords(ids){
    const store = txObjectStore('readonly');
    return Promise.all(ids.map(id=>new Promise((res,rej)=>{ const r = store.get(id); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error)})));
  }
  function metaGet(key){
    return new Promise((res,rej)=>{ const r = txMetaStore('readonly').get(key); r.onsuccess=()=>res(r.result? r.result.v : undefined); r.onerror=()=>rej(r.error) });
  }
  function metaPut(key,value){
    return new Promise((res,rej)=>{ const r = txMetaStore('readwrite').put({k:key,v:value}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) });
  }

  // ------------------ Binary helpers ------------------------
  const $ = sel => document.querySelector(sel);
  const fmtBytes = n => (n? (n/1024/1024).toFixed(2):'0.00')+ ' MB';
  const uid = () => crypto.randomUUID ? crypto.randomUUID() : (Date.now()+Math.random()).toString(36);
  async function blobToArrayBuffer(blob){ return await blob.arrayBuffer(); }
  function arrayBufferToBlob(ab, type){ return new Blob([ab], { type: type || 'application/octet-stream' }); }
  function u8aToBase64(u8a){
    // for exporting encrypted payload if needed
    let binary = '';
    const len = u8a.byteLength;
    for(let i=0;i<len;i++) binary += String.fromCharCode(u8a[i]);
    return btoa(binary);
  }
  function base64ToU8a(b64){
    const bin = atob(b64);
    const u8 = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
    return u8;
  }

  // ------------------ Crypto core ---------------------------
  async function deriveKeyFromPassword(password, saltBytes){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
    const derived = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt: saltBytes, iterations: PBKDF2_ITERATIONS, hash: 'SHA-256' },
      keyMaterial,
      ENC_ALGO,
      false,
      ['encrypt','decrypt']
    );
    return derived;
  }

  async function ensureSaltAndKey(password){
    // get salt from meta or create new
    const metaSalt = await metaGet(SALT_KEY);
    if(metaSalt){
      salt = Uint8Array.from(metaSalt);
    }else{
      const s = crypto.getRandomValues(new Uint8Array(16));
      salt = s;
      await metaPut(SALT_KEY, Array.from(s));
    }
    cryptoKey = await deriveKeyFromPassword(password, salt);
  }

  async function encryptArrayBuffer(ab){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, cryptoKey, ab);
    return { iv: Array.from(iv), cipher: cipher }; // cipher is ArrayBuffer
  }

  async function decryptToArrayBuffer(ivArr, cipherAB){
    const iv = new Uint8Array(ivArr);
    const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, cryptoKey, cipherAB);
    return plain; // ArrayBuffer
  }

  // ------------------ DOM elements & state -------------------
  const fileInput = $('#fileInput');
  const importInput = $('#importInput');
  const gallery = $('#gallery');
  const dropzone = $('#dropzone');
  const emptyState = $('#emptyState');
  const stats = $('#stats');
  const exportSelBtn = $('#exportSel');
  const exportAllBtn = $('#exportAll');
  const selectAllBtn = $('#selectAll');
  const clearSelBtn = $('#clearSel');
  const clearAllBtn = $('#clearAll');
  const viewer = $('#viewer');
  const viewerImg = $('#viewerImg');
  const viewerName = $('#viewerName');

  let selections = new Set();

  // ------------------ Rendering / Refresh --------------------
  async function refresh(){
    const items = await getAllRecords();
    gallery.innerHTML = '';
    let totalBytes = 0;
    items.forEach(it=> totalBytes += (it.size||0));
    stats.textContent = `${items.length} items ¬∑ ${fmtBytes(totalBytes)}`;

    exportAllBtn.disabled = items.length === 0;
    clearAllBtn.disabled = items.length === 0;
    selectAllBtn.disabled = items.length === 0;
    emptyState.classList.toggle('hidden', items.length !== 0);

    // latest first
    items.sort((a,b)=> (b.addedAt||0) - (a.addedAt||0));

    for(const it of items){
      // decrypt per item
      let blob;
      try{
        const plainAB = await decryptToArrayBuffer(it.iv, it.cipher);
        blob = arrayBufferToBlob(plainAB, it.type || 'image/*');
      }catch(err){
        console.error('Decryption failed for', it.id, err);
        // show placeholder broken item
        const cardErr = document.createElement('div');
        cardErr.className = 'card';
        cardErr.innerHTML = `<div style="padding:14px;color:var(--muted)">Unable to decrypt "${it.name}" ‚Äî maybe wrong password.</div>`;
        gallery.appendChild(cardErr);
        continue;
      }

      const url = URL.createObjectURL(blob);
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="select"><input type="checkbox" aria-label="Select ${it.name}" ${selections.has(it.id)?'checked':''}></div>
        <img class="thumb" src="${url}" alt="${it.name}">
        <div class="meta">
          <div class="name" title="${it.name}">${it.name}</div>
          <div class="badge">${(it.type||'image').split('/').pop().toUpperCase()}</div>
        </div>
        <div class="actions">
          <button data-act="view">View</button>
          <button data-act="del">Delete</button>
          <button data-act="dl">Download</button>
        </div>
      `;

      // Checkbox
      const cb = card.querySelector('input[type=checkbox]');
      cb.addEventListener('change', () => {
        if(cb.checked) selections.add(it.id); else selections.delete(it.id);
        updateSelectionButtons();
      });

      // View
      card.querySelector('[data-act=view]').addEventListener('click',()=>{
        viewerImg.src = url; viewerName.textContent = it.name; viewer.showModal();
      });

      // Delete
      card.querySelector('[data-act=del]').addEventListener('click', async ()=>{
        if(confirm(`Delete \"${it.name}\"?`)){
          await deleteImageRecord(it.id); selections.delete(it.id); refresh();
        }
      });

      // Download (single) ‚Äî create link to decrypted blob
      card.querySelector('[data-act=dl]').addEventListener('click',()=>{
        const a = document.createElement('a');
        a.href = url; a.download = it.name || 'image'; a.click();
      });

      // Click thumb to toggle selection
      card.querySelector('.thumb').addEventListener('click',()=>{ cb.checked=!cb.checked; cb.dispatchEvent(new Event('change')); });

      gallery.appendChild(card);
    }
    updateSelectionButtons();
  }

  function updateSelectionButtons(){
    const hasSel = selections.size>0;
    exportSelBtn.disabled = !hasSel;
    clearSelBtn.disabled = !hasSel;
  }

  // ------------------ Export / Import (decrypted export) ----------
  async function exportByIds(ids){
    const records = (await getManyRecords(ids)).filter(Boolean);
    const images = [];
    for(const r of records){
      try{
        const plainAB = await decryptToArrayBuffer(r.iv, r.cipher);
        const blob = arrayBufferToBlob(plainAB, r.type);
        const dataURL = await blobToDataURL(blob);
        images.push({ id: r.id, name: r.name, type: r.type, size: r.size, lastModified: r.lastModified, addedAt: r.addedAt, dataURL });
      }catch(err){
        console.error('Failed decrypt for export', r.id, err);
        alert('Failed to decrypt one or more items for export. Export aborted.');
        return;
      }
    }
    const payload = { version:1, exportedAt:new Date().toISOString(), images };
    const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `gallery-export-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
    a.click();
  }

  async function handleImport(file){
    try{
      const text = await file.text();
      const payload = JSON.parse(text);
      if(!payload || !Array.isArray(payload.images)) throw new Error('Invalid file');
      for(const img of payload.images){
        // convert dataURL to blob
        const blob = await (await fetch(img.dataURL)).blob();
        const ab = await blobToArrayBuffer(blob);
        const enc = await encryptArrayBuffer(ab);
        const rec = { id: uid(), name: img.name||'imported-image', type: blob.type||img.type||'image/*', size: blob.size||img.size, lastModified: img.lastModified||Date.now(), addedAt: Date.now(), cipher: enc.cipher, iv: enc.iv };
        await putImageRecord(rec);
      }
      selections.clear();
      await refresh();
      alert(`Imported ${payload.images.length} image(s).`);
    }catch(err){
      console.error(err); alert('Import failed: '+ err.message);
    }
  }

  // blob -> dataURL (used for export)
  function blobToDataURL(blob){
    return new Promise((resolve,reject)=>{ const fr = new FileReader(); fr.onload=()=>resolve(fr.result); fr.onerror=()=>reject(fr.error); fr.readAsDataURL(blob); });
  }

  // ------------------ Ingest Files (encrypt before store) -----------
  async function ingestFiles(fileList){
    const files = Array.from(fileList).filter(f=> f.type && f.type.startsWith('image/'));
    if(files.length===0){ alert('Please choose image files (including GIFs).'); return; }
    for(const f of files){
      const ab = await blobToArrayBuffer(f);
      const enc = await encryptArrayBuffer(ab);
      const rec = { id: uid(), name: f.name, type: f.type, size: f.size, lastModified: f.lastModified, addedAt: Date.now(), cipher: enc.cipher, iv: enc.iv };
      await putImageRecord(rec);
    }
    await refresh();
  }

  // ------------------ Event wiring -----------------------------
  fileInput.addEventListener('change', e=>{ if(e.target.files?.length) ingestFiles(e.target.files); e.target.value=''; });
  importInput.addEventListener('change', e=>{ if(e.target.files?.length) handleImport(e.target.files[0]); e.target.value=''; });

  dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.classList.add('dragover'); });
  dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
  dropzone.addEventListener('drop', e=>{ e.preventDefault(); dropzone.classList.remove('dragover'); if(e.dataTransfer.files?.length) ingestFiles(e.dataTransfer.files); });

  selectAllBtn.addEventListener('click', async ()=>{
    const items = await getAllRecords(); selections = new Set(items.map(i=>i.id)); refresh();
  });

  clearSelBtn.addEventListener('click', async ()=>{
    if(!selections.size) return; if(!confirm(`Delete ${selections.size} selected item(s)?`)) return;
    for(const id of selections){ await deleteImageRecord(id); }
    selections.clear(); refresh();
  });

  clearAllBtn.addEventListener('click', async ()=>{
    if(!confirm('Delete ALL images?')) return;
    const store = txObjectStore('readwrite');
    store.clear();
    selections.clear(); refresh();
  });

  exportSelBtn.addEventListener('click', async ()=>{ if(selections.size) exportByIds(Array.from(selections)); });
  exportAllBtn.addEventListener('click', async ()=>{ const items = await getAllRecords(); if(items.length) exportByIds(items.map(i=>i.id)); });

  // ------------------ Boot & Password prompt -------------------
  async function promptPasswordLoop(){
    // Simple loop prompting up to unlimited times until password works or user cancels.
    while(true){
      const password = prompt('Enter password to unlock your encrypted gallery (choose a memorable password):');
      if(password === null){
        // user cancelled
        alert('Cancelled. Page will still open but data cannot be decrypted without the password.');
        return null;
      }
      try{
        await ensureSaltAndKey(password);
        // verify if there are records and test decrypt first record (if present)
        const items = await getAllRecords();
        if(items.length === 0){
          return password; // no records to verify; key accepted
        }
        // try to decrypt first item
        try{
          const test = items[0];
          await decryptToArrayBuffer(test.iv, test.cipher);
          return password; // success
        }catch(e){
          console.warn('Password failed to decrypt an item.', e);
          alert('Incorrect password for this gallery (or data corrupted). Please try again.');
          // loop again
        }
      }catch(e){
        console.error('Key derivation error', e);
        alert('Error deriving key ‚Äî try again.');
      }
    }
  }

  (async function init(){
    try{
      db = await openDB();
      // Prompt user for password and create/derive key + salt
      await promptPasswordLoop();
      // Try to request persistent storage (optional)
      if('storage' in navigator && navigator.storage.persist){
        try{ await navigator.storage.persist(); }catch{ /* ignore */ }
      }
      await refresh();
    }catch(err){
      console.error('Init error', err); alert('Initialization failed: '+err.message);
    }
  })();

  </script>
</body>
</html>
